const e=JSON.parse('{"key":"v-4d4025c0","path":"/series/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%80%E5%8F%91%E5%85%A5%E9%AD%82/04-%E5%A0%86%E6%A0%88.html","title":"汇编语言一发入魂 0x04 - 堆栈","lang":"zh-CN","frontmatter":{"title":"汇编语言一发入魂 0x04 - 堆栈","shortTitle":"堆栈","date":"2020-03-14T08:31:56.000Z","tag":["堆栈"],"category":["汇编语言"],"description":"上一篇文章中我们实现了数字各个位的分解并打印在屏幕上。他需要我们知道数字有多少个位，并且提前预留出内存空间保存每个位，这显然不是一个完美的解决方案。现在我们来学习一下堆栈，并使用堆栈来保存分解出的每个位，实现可以分解任意位的数字。 先解释一下堆栈。实际上这个堆栈和堆(heap)并没有关系，只是一个纯粹的栈(stack)，可能是堆栈这样叫起来更上口一点吧。 堆栈段和其他段一样，只是一段普通的内存空间，只是我们限制了对这部分内存空间操作的行为。我们只允许通过push（压栈）和pop（出栈）这两个指令来操作堆栈段的内存空间，以此来实现一些算法。使用堆栈段之前需要先初始化段基址(ss)和栈顶指针(sp)，例如将ss初始化为0x0000，sp初始化为0x7c00。此时堆栈段的逻辑地址为0x0000:0x0000到0x0000:0x7c00，对应的物理地址为0x00000到0x07c00。","head":[["meta",{"property":"og:url","content":"https://kviccn.github.io/series/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%80%E5%8F%91%E5%85%A5%E9%AD%82/04-%E5%A0%86%E6%A0%88.html"}],["meta",{"property":"og:site_name","content":"未央"}],["meta",{"property":"og:title","content":"汇编语言一发入魂 0x04 - 堆栈"}],["meta",{"property":"og:description","content":"上一篇文章中我们实现了数字各个位的分解并打印在屏幕上。他需要我们知道数字有多少个位，并且提前预留出内存空间保存每个位，这显然不是一个完美的解决方案。现在我们来学习一下堆栈，并使用堆栈来保存分解出的每个位，实现可以分解任意位的数字。 先解释一下堆栈。实际上这个堆栈和堆(heap)并没有关系，只是一个纯粹的栈(stack)，可能是堆栈这样叫起来更上口一点吧。 堆栈段和其他段一样，只是一段普通的内存空间，只是我们限制了对这部分内存空间操作的行为。我们只允许通过push（压栈）和pop（出栈）这两个指令来操作堆栈段的内存空间，以此来实现一些算法。使用堆栈段之前需要先初始化段基址(ss)和栈顶指针(sp)，例如将ss初始化为0x0000，sp初始化为0x7c00。此时堆栈段的逻辑地址为0x0000:0x0000到0x0000:0x7c00，对应的物理地址为0x00000到0x07c00。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://kviccn.github.io/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-03T14:00:42.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"汇编语言一发入魂 0x04 - 堆栈"}],["meta",{"property":"article:author","content":"未央"}],["meta",{"property":"article:tag","content":"堆栈"}],["meta",{"property":"article:published_time","content":"2020-03-14T08:31:56.000Z"}],["meta",{"property":"article:modified_time","content":"2023-06-03T14:00:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"汇编语言一发入魂 0x04 - 堆栈\\",\\"image\\":[\\"https://kviccn.github.io/\\"],\\"datePublished\\":\\"2020-03-14T08:31:56.000Z\\",\\"dateModified\\":\\"2023-06-03T14:00:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"未央\\",\\"url\\":\\"https://kviccn.github.io\\"}]}"]]},"headers":[{"level":2,"title":"代码","slug":"代码","link":"#代码","children":[]},{"level":2,"title":"解释","slug":"解释","link":"#解释","children":[]},{"level":2,"title":"运行","slug":"运行","link":"#运行","children":[]},{"level":2,"title":"调试","slug":"调试","link":"#调试","children":[]}],"git":{"createdTime":1685800842000,"updatedTime":1685800842000,"contributors":[{"name":"kviccn","email":"kviccn@outlook.com","commits":1}]},"readingTime":{"minutes":6.46,"words":1937},"filePathRelative":"series/汇编语言一发入魂/04-堆栈.md","localizedDate":"2020年3月14日","excerpt":"<p>上一篇文章中我们实现了数字各个位的分解并打印在屏幕上。他需要我们知道数字有多少个位，并且提前预留出内存空间保存每个位，这显然不是一个完美的解决方案。现在我们来学习一下堆栈，并使用堆栈来保存分解出的每个位，实现可以分解任意位的数字。</p>\\n<p>先解释一下<code>堆栈</code>。实际上这个<code>堆栈</code>和<code>堆(heap)</code>并没有关系，只是一个纯粹的<code>栈(stack)</code>，可能是<code>堆栈</code>这样叫起来更上口一点吧。</p>\\n<p><code>堆栈段</code>和其他段一样，只是一段普通的内存空间，只是我们限制了对这部分内存空间操作的行为。我们只允许通过<code>push（压栈）</code>和<code>pop（出栈）</code>这两个指令来操作堆栈段的内存空间，以此来实现一些算法。使用<code>堆栈段</code>之前需要先初始化<code>段基址(ss)</code>和<code>栈顶指针(sp)</code>，例如将<code>ss</code>初始化为<code>0x0000</code>，<code>sp</code>初始化为<code>0x7c00</code>。此时堆栈段的逻辑地址为<code>0x0000:0x0000</code>到<code>0x0000:0x7c00</code>，对应的物理地址为<code>0x00000</code>到<code>0x07c00</code>。</p>","autoDesc":true}');export{e as data};
