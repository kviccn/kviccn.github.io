const e=JSON.parse('{"key":"v-2a984e7e","path":"/series/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%80%E5%8F%91%E5%85%A5%E9%AD%82/07-%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8.html","title":"汇编语言一发入魂 0x07 - 过程调用","lang":"zh-CN","frontmatter":{"title":"汇编语言一发入魂 0x07 - 过程调用","shortTitle":"过程调用","date":"2020-03-19T06:46:48.000Z","tag":["过程调用"],"category":["汇编语言"],"description":"前两篇文章中我们学习了如何控制屏幕光标，如何从硬盘读取数据。这种常用的功能我们希望将它封装成过程调用，类似于高级语言中的函数，这样当我们控制光标或者从硬盘读取数据时就不需要每次都写大段的重复代码了。 在CPU中，执行的指令通过cs:ip来确定。过程调用实际上就是通过call或lcall指令来修改ip或cs:ip来达到跳转到另一段指令中执行的目的。 call指令通过修改ip来实现过程调用，因为只修改ip，所以被调例程与原例程在同一个代码段内，也称为近调用。处理器在执行call指令时先将call后面的第一条指令的偏移地址压栈，再通过操作数计算出新的ip替换当前ip。","head":[["meta",{"property":"og:url","content":"https://kviccn.github.io/series/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%80%E5%8F%91%E5%85%A5%E9%AD%82/07-%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8.html"}],["meta",{"property":"og:site_name","content":"未央"}],["meta",{"property":"og:title","content":"汇编语言一发入魂 0x07 - 过程调用"}],["meta",{"property":"og:description","content":"前两篇文章中我们学习了如何控制屏幕光标，如何从硬盘读取数据。这种常用的功能我们希望将它封装成过程调用，类似于高级语言中的函数，这样当我们控制光标或者从硬盘读取数据时就不需要每次都写大段的重复代码了。 在CPU中，执行的指令通过cs:ip来确定。过程调用实际上就是通过call或lcall指令来修改ip或cs:ip来达到跳转到另一段指令中执行的目的。 call指令通过修改ip来实现过程调用，因为只修改ip，所以被调例程与原例程在同一个代码段内，也称为近调用。处理器在执行call指令时先将call后面的第一条指令的偏移地址压栈，再通过操作数计算出新的ip替换当前ip。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-04T14:47:29.000Z"}],["meta",{"property":"article:author","content":"未央"}],["meta",{"property":"article:tag","content":"过程调用"}],["meta",{"property":"article:published_time","content":"2020-03-19T06:46:48.000Z"}],["meta",{"property":"article:modified_time","content":"2023-06-04T14:47:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"汇编语言一发入魂 0x07 - 过程调用\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-03-19T06:46:48.000Z\\",\\"dateModified\\":\\"2023-06-04T14:47:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"未央\\",\\"url\\":\\"https://kviccn.github.io\\"}]}"]]},"headers":[{"level":2,"title":"示例一","slug":"示例一","link":"#示例一","children":[{"level":3,"title":"代码","slug":"代码","link":"#代码","children":[]},{"level":3,"title":"解释","slug":"解释","link":"#解释","children":[]},{"level":3,"title":"编译、反编译","slug":"编译、反编译","link":"#编译、反编译","children":[]},{"level":3,"title":"调试","slug":"调试","link":"#调试","children":[]}]},{"level":2,"title":"示例二","slug":"示例二","link":"#示例二","children":[{"level":3,"title":"代码","slug":"代码-1","link":"#代码-1","children":[]},{"level":3,"title":"解释","slug":"解释-1","link":"#解释-1","children":[]},{"level":3,"title":"调试","slug":"调试-1","link":"#调试-1","children":[]}]}],"git":{"createdTime":1685890049000,"updatedTime":1685890049000,"contributors":[{"name":"kviccn","email":"kviccn@outlook.com","commits":1}]},"readingTime":{"minutes":6.86,"words":2057},"filePathRelative":"series/汇编语言一发入魂/07-过程调用.md","localizedDate":"2020年3月19日","excerpt":"<p>前两篇文章中我们学习了如何控制屏幕光标，如何从硬盘读取数据。这种常用的功能我们希望将它封装成过程调用，类似于高级语言中的函数，这样当我们控制光标或者从硬盘读取数据时就不需要每次都写大段的重复代码了。</p>\\n<p>在<code>CPU</code>中，执行的指令通过<code>cs:ip</code>来确定。过程调用实际上就是通过<code>call</code>或<code>lcall</code>指令来修改<code>ip</code>或<code>cs:ip</code>来达到跳转到另一段指令中执行的目的。</p>\\n<p><code>call</code>指令通过修改<code>ip</code>来实现过程调用，因为只修改<code>ip</code>，所以被调例程与原例程在同一个代码段内，也称为近调用。处理器在执行<code>call</code>指令时先将<code>call</code>后面的第一条指令的偏移地址压栈，再通过操作数计算出新的<code>ip</code>替换当前<code>ip</code>。</p>","autoDesc":true}');export{e as data};
