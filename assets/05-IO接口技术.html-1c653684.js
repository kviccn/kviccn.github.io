import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as c,c as i,b as a,d as e,e as t,a as d}from"./app-a3b1dd03.js";const l="/assets/empty_01-4e0e25ef.png",r="/assets/empty_02-da4e8b89.png",p={},u=d(`<p><code>I/O</code>接口用于<code>CPU</code>与外部<code>I/O</code>设备进行信息交换。例如与键盘、鼠标、打印机和显示等设备交互。<code>I/O</code>接口电路与总线系统看似很复杂，但是落实到汇编语言代码上实则是很简单的。下面简要介绍一下<code>I/O</code>接口技术。</p><h2 id="i-o-接口技术" tabindex="-1"><a class="header-anchor" href="#i-o-接口技术" aria-hidden="true">#</a> I/O 接口技术</h2><p>在计算机中，<code>CPU</code>与外设并不是直接相连的，在它们中间设有<code>I/O</code>接口电路。<code>CPU</code>通过数据总线、地址总线和控制总线与<code>I/O</code>接口电路相连，以实现与外设交换数据信息、状态信息和控制信息。外设的状态信息通过接口电路的状态端口经由数据总线进入<code>CPU</code>，而<code>CPU</code>向外设发出的控制信号也是经由数据总线，通过接口电路的控制端口来实现的。</p><h3 id="i-o-端口" tabindex="-1"><a class="header-anchor" href="#i-o-端口" aria-hidden="true">#</a> I/O 端口</h3><p>具体来说，<code>CPU</code>是通过<code>I/O</code>端口和外设交互的。<code>I/O</code>端口是接口电路中能被<code>CPU</code>直接访问的寄存器或存储器。通常，根据数据性质，<code>I/O</code>接口电路中可分为<code>3</code>种类型的端口，即<code>数据端口</code>、<code>状态端口</code>和<code>控制端口</code>。</p><ol><li><p>数据端口。用于存放<code>CPU</code>与外设之间交换的数据，数据的长度通常为<code>1~2</code>个字节。</p></li><li><p>状态端口。用于指示外设的当前状态。每种状态用<code>1</code>位二进制数据表示，可由<code>CPU</code>通过数据总线和相关电路读取。状态端口的不同状态位的含义有：</p><ul><li><p>准备就绪位<code>(ready)</code>。对于输入端口，<code>ready=1</code>表示数据寄存器已准备好数据，等待<code>CPU</code>读取；当数据取走后，此位由<code>CPU</code>清零；对于输出端口，<code>ready=1</code>表示输出数据寄存器已空，可以接受下一个数据；当新数据到达后，该位由外设清零。</p></li><li><p>忙位<code>(busy)</code>。<code>busy</code>表明外设是否能够接收数据。<code>busy=1</code>表示外设忙，暂时不允许<code>CPU</code>送数据过来。<code>busy=0</code>表示外设已空闲，允许<code>CPU</code>发送下一个数据。</p></li><li><p>错误位<code>(error)</code>。<code>error=1</code>表示在数据传送过程中出现错误，<code>CPU</code>正在进行相应的处理，重新传送或中止操作等。</p></li></ul></li><li><p>控制端口。用于存放<code>CPU</code>向接口发出的各种命令、控制字和控制信号，以便控制外设的不同操作。</p></li></ol><h3 id="i-o-端口的寻址方式" tabindex="-1"><a class="header-anchor" href="#i-o-端口的寻址方式" aria-hidden="true">#</a> I/O 端口的寻址方式</h3><p><code>CPU</code>对端口的寻址方式通常有两种：</p><ol><li>存储器统一编址。又称为存储器映像编址，在这种编址方式中，<code>I/O</code>端口和内存单元统一编址，即把<code>I/O</code>端口当作内存单元对待，从整个内存空间中划出一个子空间给<code>I/O</code>端口，每一个<code>I/O</code>端口分配一个地址码，用访问存储器的指令对<code>I/O</code>端口进行操作。典型的例子是我们一直在使用的显存缓冲区，虽然我们使用的是操作内存的方式，但实际上操作的是显卡。</li><li><code>I/O</code>独立编址。<code>I/O</code>端口编址和存储器的编址相互独立，即<code>I/O</code>端口地址空间和存储器地址空间分开设置，互不影响。采用这种编址方式，对<code>I/O</code>端口的操作使用输入/输出指令（<code>I/O</code>指令）。</li></ol><h3 id="i-o-端口地址分配" tabindex="-1"><a class="header-anchor" href="#i-o-端口地址分配" aria-hidden="true">#</a> I/O 端口地址分配</h3><table><thead><tr><th>端口地址范围</th><th>分配说明</th></tr></thead><tbody><tr><td>0x000 --- 0x01F</td><td>8237A DMA控制器1</td></tr><tr><td>0x020 --- 0x03F</td><td>8259A可编程中断控制器1</td></tr><tr><td>0x040 --- 0x05F</td><td>8253/8254A 定时计数器</td></tr><tr><td>0x060 --- 0x06F</td><td>8042键盘控制器</td></tr><tr><td>0x070 --- 0x07F</td><td>CMOS RAM/实时时钟RTC</td></tr><tr><td>0x080 --- 0x09F</td><td>DMA页面寄存器访问端口</td></tr><tr><td>0x0A0 --- 0x0BF</td><td>8259A可编程中断控制器2</td></tr><tr><td>0x0C0 --- 0x0DF</td><td>8237A DMA控制器2</td></tr><tr><td>0x0F0 --- 0x0FF</td><td>协处理器访问端口</td></tr><tr><td>0x170 --- 0x177</td><td>IDE硬盘控制器1</td></tr><tr><td>0x1F0 --- 0x1F7</td><td>IDE硬盘控制器0</td></tr><tr><td>0x278 --- 0x27F</td><td>并行打印机端口2</td></tr><tr><td>0x2F8 --- 0x2FF</td><td>串行控制器2</td></tr><tr><td>0x378 --- 0x37F</td><td>并行打印机端口1</td></tr><tr><td>0x3B0 --- 0x3BF</td><td>单色MDA显示控制器</td></tr><tr><td>0x3C0 --- 0x3CF</td><td>彩色CGA显示控制器</td></tr><tr><td>0x3D0 --- 0x3DF</td><td>彩色EGA/VGA显示控制器</td></tr><tr><td>0x3F0 --- 0x3F7</td><td>软盘控制器</td></tr><tr><td>0x3F8 --- 0x3FF</td><td>串行控制器1</td></tr></tbody></table><h2 id="实验" tabindex="-1"><a class="header-anchor" href="#实验" aria-hidden="true">#</a> 实验</h2><p>这一小节老李给大家介绍一下关于屏幕光标的一些知识，并借助<code>QEMU</code>提供的访问<code>I/O</code>端口的能力在不写代码的情况下体验一下<code>I/O</code>端口的操作。</p><h3 id="屏幕光标控制" tabindex="-1"><a class="header-anchor" href="#屏幕光标控制" aria-hidden="true">#</a> 屏幕光标控制</h3><p>我们从控制屏幕光标来学习<code>I/O</code>端口的操作，因为控制屏幕光标很简单，只需要操作两个端口即可。</p><p>在之前的学习中，我们知道了计算机启动后显卡默认被初始化到<code>标准 VGA 文本模式</code>，该模式下屏幕总共可以显示<code>80 x 25 = 2000</code>个字符。从<code>0</code>开始计数，光标的范围在数值上为<code>0~1999</code>。光标在屏幕上的位置保存在显卡内部的两个光标寄存器中，每个寄存器都是<code>8</code>位的，合起来形成一个<code>16</code>位的数值。这两个寄存器在显卡内部的索引值分别是<code>14(0x0e)</code>和<code>15(0x0f)</code>，分别用于提供光标位置的高<code>8</code>位和低<code>8</code>位。在读写这两个寄存器之前需要先通过索引寄存器指定它们的索引，索引寄存器的端口号是<code>0x3d4</code>。指定了寄存器之后，就可以通过数据端口<code>0x3d5</code>来进行读写了。</p><p>下面就让我们通过<code>QEMU</code>来体验一下如何操作<code>I/O</code>端口。配合这个实验的主引导扇区代码如下：</p><div class="language-asm line-numbers-mode" data-ext="asm"><pre class="language-asm"><code>.code16

jmp .

.org 510
.word 0xAA55
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码只有一个功能，就是陷入死循环。下面启动虚拟机：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ as <span class="token parameter variable">--32</span> empty.s <span class="token parameter variable">-o</span> empty.o
$ objcopy <span class="token parameter variable">-O</span> binary <span class="token parameter variable">-j</span> .text empty.o empty.bin
$ qemu-system-i386 empty.bin <span class="token parameter variable">-monitor</span> stdio
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+l+`" alt="empty_01" tabindex="0" loading="lazy"><figcaption>empty_01</figcaption></figure><p>可以看到光标的默认位置在<code>B</code>下方，我们通过端口将光标的实际位置取出来，看看和我们肉眼所见的位置一不一样。</p><p>需要注意的一点是这次我们启动虚拟机的时候加了参数<code>-monitor stdio</code>，这会使标准输入输出设备与<code>QEMU</code>的<code>监视器</code>关联，我们可以直接在终端向虚拟机发命令，而不需要每次都通过<code>Ctrl-Alt-2</code>切换到<code>监视器</code>。</p><p>向索引寄存器的端口<code>0x3d4</code>写入<code>0xe</code>，因为我们接下来准备读取光标位置的高<code>8</code>位：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> o/1xb 0x3d4 0xe
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这是<code>QEMU</code>提供的读写<code>I/O</code>端口的命令，并不是汇编指令，这一点不要搞混。</p><p>从数据端口<code>0x3d5</code>读取光标位置高<code>8</code>位：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> i/1xb 0x3d5
portb<span class="token punctuation">[</span>0x03d5<span class="token punctuation">]</span> <span class="token operator">=</span> 0x2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>结果是<code>0x2</code>。</p><p>再用同样的方式读取光标位置低<code>8</code>位：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> o/1xb 0x3d4 0xf
<span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> i/1xb 0x3d5
portb<span class="token punctuation">[</span>0x03d5<span class="token punctuation">]</span> <span class="token operator">=</span> 0x80
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果是<code>0x80</code>，将高<code>8</code>位与低<code>8</code>位组合在一起得到<code>0x280</code>，即十进制<code>640</code>，除以每行字符数<code>80</code>，得到<code>8</code>。即第<code>8</code>行，从<code>0</code>开始计。可能不太好数，我们来换个方式，把位置<code>0</code>写入到光标位置寄存器，看看光标会发生什么变化。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> o/1xb 0x3d4 0xe
<span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> o/1xb 0x3d5 <span class="token number">0</span>
<span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> o/1xb 0x3d4 0xf
<span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> o/1xb 0x3d5 <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时的结果如下： <img src="`+r+'" alt="empty_02" loading="lazy"></p><p>可以看到光标已经在左上角的位置了。</p>',35),v=a("code",null,"Qemu",-1),b=a("code",null,"1xb",-1),m={href:"https://www.qemu.org/docs/master/system/monitor.html",target:"_blank",rel:"noopener noreferrer"},x=d(`<h2 id="实战" tabindex="-1"><a class="header-anchor" href="#实战" aria-hidden="true">#</a> 实战</h2><p>下面我们使用汇编语言完成和上面一样的功能，当程序运行完成后，光标的初始位置被保存在<code>cx</code>中。</p><h3 id="代码" tabindex="-1"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h3><div class="language-asm line-numbers-mode" data-ext="asm"><pre class="language-asm"><code>.code16

# 将初始光标位置读入 cx
movw $0x3d4, %dx
movb $0xe, %al
outb %al, %dx

movw $0x3d5, %dx
inb %dx, %al
movb %al, %ch

movw $0x3d4, %dx
movb $0xf, %al
outb %al, %dx

movw $0x3d5, %dx
inb %dx, %al
movb %al, %cl

# 设置光标位置为 0
movw $0x3d4, %dx
movb $0xe, %al
outb %al, %dx

movw $0x3d5, %dx
movb $0, %al
outb %al, %dx

movw $0x3d4, %dx
movb $0xf, %al
outb %al, %dx

movw $0x3d5, %dx
movb $0, %al
outb %al, %dx

jmp .

.org 510
.word 0xAA55
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="解释" tabindex="-1"><a class="header-anchor" href="#解释" aria-hidden="true">#</a> 解释</h3><p>第<code>4~6</code>行使用<code>out</code>指令将<code>0xe</code>写入端口<code>0x3d4</code>，用于设置要访问的寄存器的索引。<code>out</code>指令的格式是固定的，源操作数必须是寄存器<code>al</code>或者<code>ax</code>，目的操作数可以是<code>8</code>位立即数或者寄存器<code>dx</code>。因为目标端口是一个<code>8</code>位端口，所以使用<code>al</code>寄存器；因为端口号<code>0x3d5</code>大于<code>0xff（8位立即数能表示的最大端口号）</code>，所以使用<code>dx</code>寄存器。</p><p>第<code>8、9</code>行从数据端口<code>0x3d5</code>读取数据到<code>al</code>。<code>in</code>指令的格式与<code>out</code>指令正好相反。</p><p>第<code>10</code>行将光标位置的高<code>8</code>位从<code>al</code>移动到<code>ch</code>，因为稍后还要使用<code>al</code>。</p><p>第<code>12~18</code>行用于读出光标位置的低<code>8</code>位并移动到<code>cl</code>中。此时<code>cx</code>中保存着光标完整的位置。</p><p>剩下的指令用于将光标位置的高<code>8</code>位和低<code>8</code>位分别置为<code>0</code>。</p><h3 id="运行" tabindex="-1"><a class="header-anchor" href="#运行" aria-hidden="true">#</a> 运行</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ as <span class="token parameter variable">--32</span> boot.s <span class="token parameter variable">-o</span> boot.o
$ objcopy <span class="token parameter variable">-O</span> binary <span class="token parameter variable">-j</span> .text boot.o boot.bin
$ qemu-system-i386 boot.bin <span class="token parameter variable">-monitor</span> stdio
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果与上面一致，就不贴图了。此时我们查看寄存器的值：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> info registers
<span class="token assign-left variable">EAX</span><span class="token operator">=</span>0000aa00 <span class="token assign-left variable">EBX</span><span class="token operator">=</span>00000000 <span class="token assign-left variable">ECX</span><span class="token operator">=</span>00000280 <span class="token assign-left variable">EDX</span><span class="token operator">=</span>000003d5
<span class="token assign-left variable">ESI</span><span class="token operator">=</span>00000000 <span class="token assign-left variable">EDI</span><span class="token operator">=</span>00000000 <span class="token assign-left variable">EBP</span><span class="token operator">=</span>00000000 <span class="token assign-left variable">ESP</span><span class="token operator">=</span>00006f04
<span class="token assign-left variable">EIP</span><span class="token operator">=</span>00007c30 <span class="token assign-left variable">EFL</span><span class="token operator">=</span>00000202 <span class="token punctuation">[</span>-------<span class="token punctuation">]</span> <span class="token assign-left variable">CPL</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">II</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">A20</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">SMM</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">HLT</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token punctuation">..</span>.
<span class="token punctuation">(</span>qemu<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>内容比较多，我们只关注第<code>2</code>行的<code>ecx</code>，值为<code>0x280</code>。与我们之前手动取出来的值是一致的。</p>`,15);function h(k,g){const n=o("ExternalLinkIcon");return c(),i("div",null,[u,a("p",null,[a("em",null,[e("上面用到的"),v,e("命令的格式我并没有解释，"),b,e("分别代表什么请查看"),a("a",m,[e("文档"),t(n)]),e("。")])]),x])}const _=s(p,[["render",h],["__file","05-IO接口技术.html.vue"]]);export{_ as default};
