---
title: C 语言内联汇编
date: 2020-05-28T21:28:24+08:00
description:
tag:
  - C 语言
  - 汇编语言
  - 内联汇编
---

在任何一个搜索引擎中输入关键字`C语言内联汇编`都能搜索到八百个结果，但是`纸上得来终觉浅`。别人的文章写的再好也比不上自己敲一遍在总结出来。老李在这里做一个粗浅的总结，觉得不够深入的朋友还是去看看那八百篇文章。

为什么要学习 C 语言内联汇编？想必当你在搜索引擎中敲下这几个字的时候就已经有了答案，话不多说，看代码。

```c
int main(void)
{
  return 0;
}
```

你没有看错，这段代码里并没有内联汇编，但我还是想从这个栗子开始。这是一段没有任何意义的代码，它唯一的作用可能就是向操作系统返回`0`吧。

在`linux`环境下编译并运行这个程序。

```bash
$ cc -m32 -fno-pic -g demo.c -o demo
$ ./demo
```

没有任何输出，但是我们可以查看它的返回结果。在`shell`中，`$?`代表上一个命令执行后的退出状态。

```bash
$ echo $?
0
```

没有意外，是`0`。你可能从来都不会在意编译器会把这段简单的代码编译成什么样子，但是当你决定学习`内联汇编`的时候，你就需要知道它究竟会被编译成什么样子。为了清晰我决定反编译这段代码对应的`目标文件`，因为在链接之后的可执行文件里加入了太多和程序主流程无关的东西。

编译：

```bash
$ cc -m32 -fno-pic -g -c demo.c -o demo.o
```

反编译：

```bash
$ objdump -d -Msuffix demo.o

demo.o：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <main>:
   0:   55                      pushl  %ebp
   1:   89 e5                   movl   %esp,%ebp
   3:   b8 00 00 00 00          movl   $0x0,%eax
   8:   5d                      popl   %ebp
   9:   c3                      retl
```

这里我们不讲汇编语言的基础，反编译后的代码放在这里用来和后续的代码做对比。

继续下一个栗子。

```c
int main(void)
{
  asm("nop");
  return 0;
}
```

和最初的版本比起来多了一行，`asm("")`包裹起来的就是我们内联的汇编语言代码。我们内联了`nop`指令，这个指令使处理器空转一个`时钟周期`，换句话说，这个指令让处理器什么都不做。

运行结果也一样，还是向操作系统返回`0`。我们还是看一下反编译后的结果。

```bash
$ cc -m32 -fno-pic -g -c demo.c -o demo.o
$ objdump -d -Msuffix demo.o

demo.o：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <main>:
   0:   55                      pushl  %ebp
   1:   89 e5                   movl   %esp,%ebp
   3:   90                      nop
   4:   b8 00 00 00 00          movl   $0x0,%eax
   9:   5d                      popl   %ebp
   a:   c3                      retl
```

对比之前的结果，意料之中。第`12`行多了一行指令，就是我们在`C 语言`源代码中内联的`nop`指令。

这肯定无法让你分泌更多的多巴胺，但在这之前你还是需要先做一个平平无奇的练习，如下。

```c
int main(void)
{
  asm("movl $1, %eax\n\t"
      "movl $4, %ebx\n\t"
      "int $0x80");

  return 0;
}
```

编译，运行，查看返回值。

```bash
$ cc -m32 -fno-pic -g demo.c -o demo
$ ./demo
$ echo $?
4
```

这次返回给操作系统的并不是`0`，而是`4`，第`4`行代码中的`4`。

为了美观我们使用了 C 语言中自动连接两个相邻双引号中的字符串的技巧，所以这三行汇编代码实际上等于`movl $1, %eax\n\tmovl $4, %ebx\n\tint $0x80`。这也解释了为什么前两行的行尾要加`换行符`和`制表符`，换行符用于分割每一条汇编指令，制表符使编译器编译时产生的汇编指令格式保持规范。当然，你也可以把它们换成分号。

这三行汇编指令的作用是以参数`4`调用`linux`的系统调用`exit`，`4`作为退出状态。`movl $1, %eax`将数字`1`放入寄存器`%eax`，这是`linux`系统调用`exit`的编号。`movl $4, %ebx`将程序的退出状态放入寄存器`%ebx`，这也是规定，调用`exit`之前必须将退出状态放在这里。`int $0x80`触发`0x80`号中断，该中断的处理过程就是内核会去查询`%eax`拿到系统调用编号然后执行相应的操作。所以程序在执行到`return 0`之前就已经通过`exit(4)`退出了，退出状态为`4`。

再来看下一个栗子，在这个例子中，我们会让 C 语言和汇编指令产生交互。

```c
#include <stdio.h>

int main(void)
{
  int x = 3, y = 4, z;

  asm("addl %%ebx, %%eax"
      : "=a"(z)        /* 输出变量列表（可选）*/
      : "b"(x), "a"(y) /* 输入变量列表（可选）*/
      : /* 被破坏的寄存器列表（可选）*/);

  printf("%d + %d = %d\n", x, y, z);

  return 0;
}
```

编译运行：

```bash
$ cc -m32 -fno-pic -g demo.c -o demo
$ ./demo
3 + 4 = 7
```

汇编指令部分是`addl %%ebx, %%eax`，寄存器前多加了一个`%`。因为`%`在 C 语言中是特殊字符，所以要多加一个区分。随后是输出变量列表，我们只有一个输出变量`z`，前面双引号中的是`约束条件`，`=`号指定它是输出操作数，`a`表示把`%eax`和`z`对应起来，最终的结果是`%eax`的值会输出到变量`z`中。接着是输入变量列表，`x, y`两个输入变量，使用`逗号`隔开。`x`的约束条件是`b`，表示把`%ebx`和`x`关联起来；`y`的约束条件是`a`，表示把`%eax`和`y`关联起来。

上面的栗子是一个标准的`内联汇编`的示例。下面给出`内联汇编`的代码框架：

```c
asm("汇编指令1\n\t"
    "汇编指令2\n\t"
    "汇编指令3\n\t"
    "汇编指令n"
    : 输出变量列表（可选）
    : 输入变量列表（可选）
    : 被破坏的寄存器列表（可选）);
```

在给出部分约束条件的含义：

| 约束条件 | 含义                         |
| :------: | :--------------------------- |
|    a     | 使用寄存器 eax               |
|    b     | 使用寄存器 ebx               |
|    c     | 使用寄存器 ecx               |
|    d     | 使用寄存器 edx               |
|    S     | 使用 esi                     |
|    D     | 使用 edi                     |
|    q     | 使用动态分配字节可寻址寄存器 |
|    r     | 使用任意动态分配的寄存器     |
|    A     | 使用寄存器 eax 与 edx 联合   |
|    m     | 使用内存地址                 |
|    o     | 使用内存地址并可以加偏移量   |
|    I     | 使用常数 0-31                |
|    J     | 使用常数 0-63                |
|    K     | 使用常数 0-255               |
|    M     | 使用常数 0-3                 |
|    N     | 使用一字节常数 0-255         |

如果参数过多，每一个寄存器都要自己定的话很麻烦。这时我们可以使用约束条件`r`和`占位符`让编译器帮我们决定用哪个寄存器。改造上面的栗子如下：

```c
#include <stdio.h>

int main(void)
{
  int x = 1, y = 2;

  asm("addl %1, %0"
      : "=r"(y)        /* 输出变量列表（可选）*/
      : "r"(x), "0"(y) /* 输入变量列表（可选）*/
      : /* 被破坏的寄存器列表（可选）*/);

  printf("1 + 2 = %d\n", y);

  return 0;
}
```

`占位符`用来表示输入输出变量，规则是从输出列表开始，一直到输入列表结束，从左到右，从上到下依次为`%0, %1, %2...`。所以输出列表中的第一个变量`y`用`%0`表示，然后到输入列表中的第一个变量`x`，用`%1`表示。第二个变量`y`在之前已经出现过，所以在约束条件处填`0`，把它们关联起来。除此之外，约束条件`r`告诉编译器，由编译器分配具体的寄存器。

编译运行：

```bash
$ cc -m32 -fno-pic -g demo.c -o demo
$ ./demo
1 + 2 = 3
```

掌握了这些知识点实际上已经够用了，但是被破坏的寄存器列表我们没有讲。因为现在的编译器已经很智能了，比如说上面我们将`%ebx`和`x`关联，将`%eax`和`y`关联，实际上如果你查看反编译后的代码会发现，编译器已经将它们保护起来了。当以后如果碰到一些被隐式操作到的寄存器时记得将他们写到`被破坏的寄存器列表`中就可以了。
